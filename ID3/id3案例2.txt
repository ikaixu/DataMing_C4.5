%现在研究的是一段matlab代码，matlab是以矩阵为基础的数据结构
%之前的那个案例使用python实现，基本的数据结构是嵌套的python列表
%目前是想读懂这段代码，然后使用numpy包改写


%主程序：输入和输出，输入数据矩阵，输出什么？看createTree函数的定义。

    %% Decision Tree  
    % ID3  
     
    %导入数据，这里是根据原始数据直接创建了一个数据矩阵。     
      
    data = [0,2,0,0,0;  
        0,2,0,1,0;  
        1,2,0,0,1;  
        2,1,0,0,1;  
        2,0,1,0,1;  
        2,0,1,1,0;  
        1,0,1,1,1;  
        0,1,0,0,0;  
        0,0,1,0,1;  
        2,1,1,0,1;  
        0,1,1,1,1;  
        1,1,0,1,1;  
        1,2,1,0,1;  
        2,1,0,1,0];  
      
    % 生成决策树  
    createTree(data)；  



%下面的是创建createTree函数的详情

    function [ output_args ] = createTree( data )  %%createTree输入为data矩阵，输出为output_args需要搞清楚
        [m,n] = size(data);  %%size函数返回data的行数和列数，m行n列，是一个int
        
        disp('original data:');  %%disp函数意思是print，打印字符串
        disp(data);  %%打印data的内容，这是output_args之一
        
        classList = data(:,n);  %%提取data的最后一列数据，classList是一个m维的列向量
        classOne = 1;  %记录第一个类的个数  
        for i = 2:m  
            if classList(i,:) == classList(1,:)  %%判断classList的除第一行外其余行的元素是否和第一行的元素相等
                classOne = classOne+1;  %%如果相等计数加一
            end  
        end  %%这个for循环做了一个计数处理，能否找到一个api有相同的功能。
          
        % 类别全相同（终止条件一）  
        if classOne == m  %%classOne的个数与m相同，就是说输入数据完全属于同一个类
            disp('final data: ');  
            disp(data);  
            return;  
        end  %%output_args之一
          
        % 特征全部用完（终止条件二） 
        if n == 1  %%输入数据只有一列，怎么破？
            disp('final data: ');  
            disp(data);  
            return;  
        end  %%output_args之一
         


         %%下面是核心代码，但是相当简洁，原因是使用了函数抽象。 

        bestFeat = chooseBestFeature(data);  %%调用下面函数，字面含义是找个节点
        disp(['bestFeat: ', num2str(bestFeat)]);  %%打印当前数据集下的最优节点是什么
        featValues = unique(data(:,bestFeat));  %%unique函数，似乎是去除含有根节点属性后的子集？？重点研究
        numOfFeatValue = length(featValues);  %%计算长度，featValue的长度。
        for i = 1:numOfFeatValue  %%递归调用
            createTree(splitData(data, bestFeat, featValues(i,:)));  
            disp('-------------------------');  
        end  
    end  







%下满函数输出bestFeature，函数名称chooseBestFeature，选择最佳特征，选节点的函数。关键

    %% 选择信息增益最大的特征  
    function [ bestFeature ] = chooseBestFeature( data )  
        [m,n] = size(data);% 得到数据集的行列信息，m记录行数，n记录列数 
          
        % 统计特征的个数  
        numOfFeatures = n-1;%最后一列是类别  
        % 原始的熵，调用函数见下面的定义  
        baseEntropy = calEntropy(data);  
          
        bestInfoGain = 0;%初始化信息增益  
        bestFeature = 0;% 初始化最佳的特征位  
          
        % 挑选最佳的特征位  
        for j = 1:numOfFeatures  
            featureTemp = unique(data(:,j));  %再次用到unique函数
            numF = length(featureTemp);%属性的个数  
            newEntropy = 0;%划分之后的熵  
            for i = 1:numF  
                subSet = splitData(data, j, featureTemp(i,:));  
                [m_1, n_1] = size(subSet);  
                prob = m_1./m;  
                newEntropy = newEntropy + prob * calEntropy(subSet);  
            end  
              
            %计算增益  
            infoGain = baseEntropy - newEntropy;  
              
            if infoGain > bestInfoGain  
                bestInfoGain = infoGain;  
                bestFeature = j;  
            end  
        end  
    end  




%计算熵的函数，在计算最佳特征的时候会使用。返回值是entropy.

    function [ entropy ] = calEntropy( data )  
        [m,n] = size(data);  
          
        % 得到类别的项，m维的列向量  
        label = data(:,n);  
          
        % 处理完的label，这里unique函数是跳出label中不重复的元素,形成一个列向量  
        label_deal = unique(label);  
          
        numLabel = length(label_deal);  %这里算出有哪几类,是个int
        prob = zeros(numLabel,2);  %zeros函数,生成一个零矩阵,行数是numLabel,列数是2
          
        % 统计标签  
        for i = 1:numLabel  
            prob(i,1) = label_deal(i,:);  %%在零矩阵中添加数据,第1列填充上label_deal相应的值
            for j = 1:m  
                if label(j,:) == label_deal(i,:)  
                    prob(i,2) = prob(i,2)+1;  
                end  
            end  
        end  
          
        % 计算熵,刚才的矩阵起了作用  
        prob(:,2) = prob(:,2)./m;  
        entropy = 0;  
        for i = 1:numLabel  
            entropy = entropy - prob(i,2) * log2(prob(i,2));  
        end  
    end  




%划分数据集的函数，结果是subSet


    function [ subSet ] = splitData( data, axis, value )  
        [m,n] = size(data);%得到待划分数据的大小  
          
        subSet = data;  
        subSet(:,axis) = [];  
        k = 0;  
        for i = 1:m  
            if data(i,axis) ~= value  
                subSet(i-k,:) = [];  
                k = k+1;  
            end  
        end     
    end  
